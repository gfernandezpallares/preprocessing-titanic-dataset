---
title: "Preprocessing Titanic Dataset"
author: "Guillem Fernández Pallarès i Miquel Tomé Carreño"
date: '`r format(Sys.Date(),"%e de %B, %Y")`'
toc-title: "Índex"
output:
  pdf_document:
    number_sections: true
    toc: true
header-includes:
  \DeclareUnicodeCharacter{0007}{}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Descripció del dataset

El dataset escollit ha estat *Titanic: Machine Learning from Disaster* disponible [a aquest enllaç](https://www.kaggle.com/c/titanic/data). Amb aquest joc de dades es pretenen aplicar algorismes de Machine Learning posteriors al preprocessat de les dades per crear models predictius que permetin construir un model que prevegui, en funció d'unes variables determinades, un determinat passatger sobreviurà o no al conegut accident.

El dataset descarregat es composa de 3 fitxers, els quals es troben en format `csv`.

El primer fitxer, `gender_submission.csv`, és un exemple del fitxer resultant a presentar un cop realitzat l'exercici, i conté una relació dels passatgers que van sobreviure amb dues columnes: identificador del passatger i el sexe (0 = Dona i 1 = Home). 

Els altres dos fitxers contenen el conjunt de dades que ens serviran per entrenar l'algorisme (conjunt `train.csv`) i les dades de test (conjunt `test.csv`) que ens serviran per calcular el nivell de precisió en les prediccions del nostre algorisme i que seran les dades que haurem d'entregar per tal que se'ns valori en la competició de Kaggle. 

En una primera inspecció, veiem que el conjunt d'entrenament consta de 891 registres, mentre que el de test en té 418. Per saber com funciona la divisió de les dades entre els conjunts train i test és bo mirar [aquest vídeo](https://materials.campus.uoc.edu/cdocent/PID_00251986/).

# Integració i selecció de dades

Les dades utilitzades es troben dividides en dos datasets diferents: un d'ells conté el subconjunt de dades que serà utilitzat al set d'entrenament o *training set* i l'altre conté aquelles que seran utilitzades al test de prova o *testing set* per comprovar l'eficàcia del model construït. Els dos subconjunts s'integraran en un de sol per dur a terme el preprocessat de les dades.

Primerament, es llegiran ambdós fitxers i s'afegirà una columna a cadascun d'ells que indicarà si un determinat registre pertany al subconjunt d'entrenament o de prova. Addicionalment, cal esmentar que al subset de prova s'ha afegit la columna `Survived` amb valors perduts `NA`, que és la variable dicotòmica a predir i que està present a l'altre subset.

```{r read files}
# Lectura del training set.
r_train <- read.csv("train.csv")
summary(r_train)

# Lectura del testing set i addició de la variable a predir.
r_test <- read.csv("test.csv")
r_test$Survived <- NA
summary(r_test)


# Addició de la columna amb la classificació train-test.
r_train$train_test <- "train"
r_test$train_test <- "test"

# Concatenació dels dos subsets.
data <- rbind(r_train,
              r_test)

# Comprovació que s'ha concatenat correctament.
nrow(r_train) + nrow(r_test) == nrow(data)
```

Pel que fa a la selecció de les dades, es trindran en compte la totalitat de registres dels quals es disposa, els quals seran considerats durant la fase de preprocessat de les dades.

# Neteja de les dades

El següent pas a dur a terme abans de l'anàlisi de les dades, és la neteja i preprocessat d'aquestes. En els dos següents apartats es realitzarà un breu estudi per determinar si existeixen valors perduts i/o valors extrems.

## Valors perduts

Primerament, s'inspeccionaran les dades de les quals es disposa amb la finalitat de trobar els valors perduts. Es consideraran tant els que tenen associat el valor `NA` com els que tenen camps en blanc. Addicionalment, es comprovarà que els `NA` introduïts manualment a la variable `Survived` en apartats anteriors es corresponen a la totalitat de valors perduts de la columna, és a dir, es comprovarà que la variable que es vol predir no contingui valors perduts al subset d'entrenament de l'algorisme.

```{r missing values}
# Total de valors perduts al dataset.
colSums(is.na(data))
colSums(data=="")

# Comprovació que les dades d'entrenament no tenen valors perduts.
sum(is.na(data$Survived[data$train_test == "train"]))
```

Com es pot observar, les columnes que contenen valors perduts són `Survived` (tot i que es corresponen amb els assignats manualment), `Age`, `Fare`, `Cabin` i `Embarked`. Es tractaran diferentment en funció del seu format.

\begin{enumerate}
  \item Els valors perduts de la variable `Survived` es deixaran sense tractar, ja que corresponen als que han estat inserits manualment a la columna per tal de poder ajuntar el subset d'entrenament i el de prova. Posteriorment, es descartarà aquesta variable quan es torni a separar els dos subconjunts de dades.
  \item A les variables `Age` i `Fare`, ambdues numèriques, es substituiran els valors perduts per la mediana de la variable. Es tria aquesta opció perquè la mediana és una mesura de tendència central menys sensible a valors extrems que la mitjana.
  \item La columna `Embarked`, corresponent al port on va embarcar el passatger en qüestió, conté una variable categòrica que no pot ser ordenada en ordre creixent o decreixent, com podria fer-se amb una variable numèrica. Per tant, en aquest cas s'associarà als valors perduts d'aquesta columna un valor desconegut `Unknown`.
\end{enumerate}

```{r treat missing values}
# Tractament variable Age.
data$Age <- ifelse(is.na(data$Age) | data$Age == "",
                   median(data$Age, na.rm = TRUE),
                   data$Age)

# Tractament variable Fare.
data$Fare <- ifelse(is.na(data$Fare) | data$Fare == "",
                    median(data$Fare, na.rm = TRUE),
                    data$Fare)

# Tractament variable Embarked.
data$Embarked <- ifelse(is.na(data$Embarked) | data$Embarked == "",
                        "Unknown",
                        data$Embarked)

# Comprovació del canvi.
colSums(is.na(data))
colSums(data=="")
```

## Valors extrems o *outliers*
           
```{r boxplot}
# Boxplot per la variable Age.
boxplot(data$Age)

# Boxplot per SibSp i Parch.
boxplot(data[c("SibSp", "Parch")])

# Taula de freqüències absolutes de Parch.
table(data$Parch)

# Boxplot per Fare.
boxplot(data$Fare)

outliers_SibSp <- boxplot.stats(data$SibSp)$out
outliers_SibSp
```